{% block map %}

<h3 style="text-align:center;">Electoral Roll Stream Processing</h3>
<h4 style="text-align:center;">Upload files for a single election and process</h4>

<!-- Election selection -->
<div style="margin-bottom: 10px;">
  <label for="election-select">Select Election:</label>
  <select id="election-select"></select>
  <button id="load-election-btn">Load Election</button>
</div>

<!-- File table -->
<div style="overflow-x:auto; border:1px solid #ccc; padding:5px; margin-bottom:20px;">
  <table id="file-table" border="1" style="border-collapse: collapse; width:100%;">
    <thead>
      <tr>
        <th>Order</th>
        <th>Filename</th>
        <th>File Type</th>
        <th>Purpose</th>
        <th>Fix Level</th>
        <th>Upload</th>
        <th>Remove</th>
      </tr>
    </thead>
    <tbody id="file-table-body">
      <!-- Populated dynamically -->
    </tbody>
  </table>
</div>

<div style="margin-bottom: 10px;">
  <button id="add-file-btn">Add File</button>
</div>

<!-- Process & Progress -->
<div>
  <button id="process-election-btn">Process Election</button>
</div>

<div id="progress-container" style="margin-top: 20px; display:none;">
  <label for="progress-bar">Normalization Progress:</label>
  <progress id="progress-bar" value="0" max="100" style="width:300px;"></progress>
  <span id="progress-text">0%</span>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {

  const qs = (sel, ctx=document) => ctx.querySelector(sel);
  const qsa = (sel, ctx=document) => [...ctx.querySelectorAll(sel)];

  let stream_processing = {
    files: [],
    last_run: null,
    status: "idle"
  };
  let selectedElection = "";

  /* =====================================================
     Fetch available elections
  ===================================================== */
  async function loadElectionOptions() {
    try {
      const elections = await fetch('/get_elections').then(res => res.json());
      const select = qs('#election-select');
      select.innerHTML = '';
      elections.forEach(e => {
        const opt = document.createElement('option');
        opt.value = e.cid;
        opt.textContent = e.name;
        select.appendChild(opt);
      });
    } catch (err) {
      alert("Error loading elections: " + err.message);
    }
  }

  /* =====================================================
     Load selected election's stream_processing
  ===================================================== */
  async function loadElection() {
    selectedElection = qs('#election-select').value;
    if (!selectedElection) return;

    try {
      stream_processing = await fetch(`/get_stream_processing/${selectedElection}`)
                                  .then(res => res.json());

      renderFileTable();
    } catch (err) {
      alert("Error loading election: " + err.message);
    }
  }

  /* =====================================================
     Render file table
  ===================================================== */
  function renderFileTable() {
    const tbody = qs('#file-table-body');
    tbody.innerHTML = '';

    stream_processing.files.forEach((file, idx) => {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td><input type="number" class="order" value="${file.order}" style="width:50px;"></td>
        <td>
          <input type="text" class="filename" value="${file.file_path?.split('/').pop() || ''}" readonly style="width:150px;">
          <input type="file" class="file-picker" style="display:none;">
        </td>
        <td>
          <select class="type">
            <option value="csv" ${file.type==='csv'?'selected':''}>csv</option>
            <option value="xlsx" ${file.type==='xlsx'?'selected':''}>xlsx</option>
            <option value="json" ${file.type==='json'?'selected':''}>json</option>
          </select>
        </td>
        <td>
          <select class="purpose">
            <option value="main" ${file.purpose==='main'?'selected':''}>main</option>
            <option value="delta" ${file.purpose==='delta'?'selected':''}>delta</option>
            <option value="avi" ${file.purpose==='avi'?'selected':''}>avi</option>
            <option value="mark" ${file.purpose==='mark'?'selected':''}>mark</option>
            <option value="resource" ${file.purpose==='resource'?'selected':''}>resource</option>
          </select>
        </td>
        <td><input type="number" class="fixlevel" value="${file.fixlevel || 0}" style="width:50px;"></td>
        <td><button class="upload-btn">üìÇ</button></td>
        <td><button class="remove-btn">‚ùå</button></td>
      `;
      tbody.appendChild(tr);

      const filePicker = tr.querySelector('.file-picker');
      tr.querySelector('.upload-btn').addEventListener('click', () => filePicker.click());
      filePicker.addEventListener('change', async (e) => {
        const f = e.target.files[0];
        if (!f) return;
        try {
          const formData = new FormData();
          formData.append('file', f);
          formData.append('election', selectedElection);
          formData.append('index', idx);

          const result = await fetch('/upload_file', {method:'POST', body: formData}).then(r=>r.json());
          if (result.error) throw new Error(result.error);

          tr.querySelector('.filename').value = f.name;
          stream_processing.files[idx].file_path = result.path;

        } catch(err) {
          alert("Upload failed: " + err.message);
        }
      });

      tr.querySelector('.remove-btn').addEventListener('click', () => {
        stream_processing.files.splice(idx, 1);
        renderFileTable();
      });
    });
  }

  /* =====================================================
     Add file
  ===================================================== */
  qs('#add-file-btn').addEventListener('click', () => {
    stream_processing.files.push({
      order: stream_processing.files.length + 1,
      file_path: '',
      type: 'csv',
      purpose: 'main',
      fixlevel: 3
    });
    renderFileTable();
  });

  /* =====================================================
     Process election
  ===================================================== */
  qs('#process-election-btn').addEventListener('click', async () => {
    if (!selectedElection || !stream_processing.files.length) {
      alert("Select an election and add files first.");
      return;
    }

    qs('#progress-container').style.display = "block";
    qs('#progress-bar').value = 0;
    qs('#progress-text').innerText = "0%";

    const formData = new FormData();
    formData.append('election', selectedElection);
    stream_processing.files.forEach((file, idx) => {
      if (file.file_path) formData.append(`stored_path_${idx}`, file.file_path);
      formData.append(`meta_${idx}_order`, file.order);
      formData.append(`meta_${idx}_type`, file.type);
      formData.append(`meta_${idx}_purpose`, file.purpose);
      formData.append(`meta_${idx}_fixlevel`, file.fixlevel);
    });

    // Start polling
    async function pollProgress() {
      try {
        const data = await fetch('/progress').then(r=>r.json());
        qs('#progress-bar').value = data.percent || 0;
        qs('#progress-text').innerText = (data.percent || 0) + "% ‚Äî " + (data.message || "");

        if (data.status !== "complete") setTimeout(pollProgress, 500);
        else qs('#progress-text').innerText = "‚úÖ Complete";

      } catch {
        setTimeout(pollProgress, 1000);
      }
    }
    pollProgress();

    try {
      await fetch('/normalise', {method:'POST', body:formData});
    } catch(err) {
      alert("Processing failed: " + err.message);
    }

  });

  qs('#load-election-btn').addEventListener('click', loadElection);

  loadElectionOptions();

});
</script>

{% endblock map %}
