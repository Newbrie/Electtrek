{% extends "base.html" %}
<script src="https://newbrie.github.io/Electtrek/static/map.js"></script>

{% block map %}
<!-- Editable File Information Table -->
<!-- Editable File Information Table -->
<h1>Electoral registers, changes and postal voter files</h1>
<h2>(Select fix level 3 to upload)</h2>
<button id="add-row-btn">Add Row</button>
<button id="save-btn">Save</button>

<table id="stream-table" border="1">
  <thead>
    <tr>
      <th>Order</th>
      <th>Election</th>
      <th>Filename</th>
      <th>Type</th>
      <th>Purpose</th>
      <th>Fixlevel</th>
      <th>Active</th>
      <th>Live</th>
    </tr>
  </thead>
  <tbody id="file-info-tbody">
    {% for row in stream_table %}
    <tr>
      <td><input type="number" class="editable order" value="{{ row['order'] }}" style="width: 60px;"></td>
      <td>
        <select class="editable election">
          {% for election in streams %}
            <option value="{{ election }}"{% if row['election'] == election %} selected{% endif %}>{{ election }}</option>
          {% endfor %}
      </select>
      </td>
      <td>
      <input type="text" class="editable filename" value="{{ row['filename'] }}" readonly style="width: 300px;">
      <input type="hidden" class="file-path" value="{{ row['file_path'] }}">
      <input type="file" class="file-picker" style="display: none;" accept=".csv,.xlsx">
      <button type="button" class="file-btn">📂</button>
      </td>
      <td>
        <select class="editable type" style="width: 60px;">
          <option value="csv" {% if row['type'] == 'csv' %}selected{% endif %}>csv</option>
          <option value="xlsx" {% if row['type'] == 'xlsx' %}selected{% endif %}>xlsx</option>
          <option value="json" {% if row['type'] == 'json' %}selected{% endif %}>json</option>
        </select>
      </td>
      <td>
        <select class="editable purpose" style="width: 60px;">
          <option value="main" {% if row['purpose'] == 'main' %}selected{% endif %}>main</option>
          <option value="delta" {% if row['purpose'] == 'delta' %}selected{% endif %}>delta</option>
          <option value="avi" {% if row['purpose'] == 'avi' %}selected{% endif %}>avi</option>
          <option value="mark" {% if row['purpose'] == 'mark' %}selected{% endif %}>mark</option>
          <option value="resource" {% if row['purpose'] == 'resource' %}selected{% endif %}>resource</option>
        </select>
      </td>
      <td><input type="number" class="editable fixlevel" value="{{ row['fixlevel'] or 0 }}" style="width: 60px;"></td>
      <td><input type="checkbox" class="editable active" {% if row['active'] and row['filename'].strip() != '' %}checked {% endif %}></td>
      <td><input type="checkbox" class="editable live" {% if row['live'] and row['live'].strip() != '' %}checked {% endif %}></td>
      <td><button class="delete-btn">Delete</button></td>
    </tr>
    {% endfor %}
  </tbody>
</table>
<!-- Import Table -->
<div id="streams" class="section">
    <h1 class="centred">DATA QUALITY DASHBOARD</h1>
    <table id="streamtab">
        <thead>
          <tr>
              <th>Election</th>
              <th>Alive</th>
              <th>Files</th>
              <th>Elect</th>
              <th>RAG</th>
          </tr>
        </thead>
        <tbody>
          {% for key, value in streamrag.items() %}
              <tr>
                  <td>{{ key }}</td>
                  <td>{{ value['Alive'] }}</td>
                  <td>{{ value['Files'] }}</td>
                  <td>{{ value['Elect'] }}</td>
                  <td>{{ value['RAG'] }}</td>
              </tr>
          {% endfor %}
          </tbody>
    </table>
  </div>
<div id="importTable" class="section">
    <table id="DQ-table">

        <thead>
          <button id="process-btn">LOAD ELECTION</button>
          <button id="reset-btn">RESET</button>
          <div id="progress-container" style="margin-top: 20px; display: none;">
            <label for="progress-bar">Normalization Progress:</label>
            <progress id="progress-bar" value="0" max="100" style="width: 300px;"></progress>
            <span id="progress-text">0%</span>
          </div>
            <tr>
                <th>Election</th>
                <th>Filename</th>
                <th>Field</th>
                <th>P0</th>
                <th>P1</th>
                <th>P2</th>
                <th>P3</th>
            </tr>
        </thead>
        <tbody>
            {% for index, row in DQstats.iterrows() %}
                <tr>
                    <td>{{ row['Election'] }}</td>
                    <td>{{ row['File'] }}</td>
                    <td>{{ row['Field'] }}</td>
                    <td>
                      <label class="maximpact-label">
                      <input type="checkbox" class="maximpact-checkbox"{% if row['P0'] == 1 %}checked{% endif %} disabled>
                      </label>
                    </td>
                    <td>
                      <label class="maximpact-label">
                      <input type="checkbox" class="maximpact-checkbox"{% if row['P1'] == 1 %}checked{% endif %} disabled>
                      </label>
                      </td>
                    <td>
                      <label class="maximpact-label">
                      <input type="checkbox" class="maximpact-checkbox"{% if row['P2'] == 1 %}checked{% endif %} disabled>
                      </label>
                    </td>
                    <td>
                      <label class="maximpact-label">
                      <input type="checkbox" class="maximpact-checkbox"{% if row['P3'] == 1 %}checked{% endif %} disabled>
                      </label>
                    </td>
                </tr>
            {% endfor %}
        </tbody>
    </table>
</div>
<script>



function collectTableData() {
  const rows = document.querySelectorAll('#file-info-tbody tr');
  const data = [];

  rows.forEach(row => {
    const rowData = {
      order: parseInt(row.querySelector('.order')?.value || "0"),
      election: row.querySelector('.election')?.value || "",
      filename: row.querySelector('.filename')?.value || "",
      type: row.querySelector('.type')?.value || "",
      purpose: row.querySelector('.purpose')?.value || "",
      fixlevel: parseInt(row.querySelector('.fixlevel')?.value || "0"),
      active: row.querySelector('.active')?.checked || false,
      file_path: row.querySelector('.file-path')?.value || ""
    };

    console.log("Row Data:", rowData);  // ✅ Log to console
    data.push(rowData);
  });

  return data;
  }


document.getElementById('reset-btn').addEventListener('click', () => {
  if (!confirm("Are you sure you want to reset Elections?")) return;

  fetch('/reset_Elections', { method: 'POST' })
    .then(res => res.json())
    .then(data => {
      alert(data.message);
// 🔄 Inject refreshed streamrag table
    fetch('/streamrag_api')
      .then(res => res.json())  // Parse the JSON response
      .then(data => {
        // Extract the 'html' and 'streamrag' from the response
        const html = data.html;
        const streamrag = data.streamrag;

        // Insert the HTML into the table
        const streamTbody = document.querySelector('#streamtab tbody');
        if (streamTbody) {
          streamTbody.innerHTML = html;
        }
        window.parent.updateMessages();
        // Now handle the 'streamrag' data (which is likely an object)
        const labels = Object.keys(streamrag);
        const dataPoints = labels.map(label => streamrag[label].Elect);
        const rags = labels.map(label => streamrag[label].RAG);

        console.log("streamtablabels:", labels);
        console.log("streamtabdata:", dataPoints);
        console.log("streamtabrags:", rags);

        // Update the chart
        window.parent.createOrUpdateChart(labels, dataPoints, rags);
      })
      .catch(error => {
        console.error('Error:', error);
      });
    })
    .catch(err => alert("Error resetting elections."));
});


    document.getElementById('save-btn').addEventListener('click', function () {
      const tableData = collectTableData();
      console.log(tableData);
      fetch('/save_stream_table', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ data: tableData })
      })
      .then(res => res.json())
      .then(data => alert("Saving tableData:"+data.message))
      .catch(err => alert("Error saving: " + err));
    });

document.getElementById('file-info-tbody').addEventListener('click', function (e) {
  if (e.target.classList.contains('file-btn')) {
         const td = e.target.closest('td');
         const row = td.closest('tr');
         const fileInput = td.querySelector('.file-picker');
         const activeCheckbox = row.querySelector('.active');
         const filenameField = td.querySelector('.filename');
         const filePathField = td.querySelector('.file-path');

         fileInput.click();

         fileInput.onchange = async function () {
             if (fileInput.files.length > 0) {
                 const file = fileInput.files[0];
                 const formData = new FormData();
                 formData.append('file', file);

                 try {
                     const res = await fetch('/upload_file', {
                         method: 'POST',
                         body: formData
                     });
                     const result = await res.json();

                     if (result.error) {
                         alert("Upload error: " + result.error);
                         return;
                     }
                     filenameField.value = file.name;
                     filePathField.value = result.path;


                     filenameField.value = file.name;
                     filePathField.value = result.path;  // backend returns full saved path
                     // Auto-check active if filename is set
                       if (file.name.trim() == '') {
                         activeCheckbox.checked = false;
                       }
                 } catch (err) {
                     alert("Failed to upload file: " + err);
                 }
             }
         };
     }

     // Unchecking active flag resets the row
     if (e.target.classList.contains('active')) {
         const checkbox = e.target;
         const row = checkbox.closest('tr');

         if (!checkbox.checked) {
             const filenameField = row.querySelector('.filename');
             const filePathField = row.querySelector('.file-path');
             const fileInput = row.querySelector('.file-picker');

             filenameField.value = '';
             filePathField.value = '';
             if (fileInput) fileInput.value = '';  // reset input so onchange re-triggers
         }
     }

  if (e.target.classList.contains('delete-btn')) {
    e.target.closest('tr').remove();
  }
});

document.getElementById('add-row-btn').addEventListener('click', function () {
const tbody = document.getElementById('file-info-tbody');
const newRow = document.createElement('tr');
newRow.innerHTML = `
  <td><input type="number" class="editable order" value="1" style="width: 60px;"></td>
  <td>
    <select class="editable election">
      {% for election in streams %}
        <option value="{{ election }}">{{ election }}</option>
      {% endfor %}
    </select>
  </td>
  <td>
    <input type="text" class="editable filename" style="width: 300px;" readonly>
    <input type="hidden" class="file-path" value="">
    <input type="file" class="file-picker" style="display: none;" accept=".csv,.xlsx">
    <button type="button" class="file-btn">📂</button>
  </td>
  <td>
    <select class="editable type" style="width: 60px;">
      <option value="csv">csv</option>
      <option value="xlsx">xlsx</option>
      <option value="json">json</option>
    </select>
  </td>
  <td>
    <select class="editable purpose" style="width: 60px;">
      <option value="main">main</option>
      <option value="delta">delta</option>
      <option value="avi">avi</option>
      <option value="mark">mark</option>
      </select>
  </td>
  <td><input type="number" class="editable fixlevel" value="0" style="width: 60px;"></td>
  <td><input type="checkbox" class="editable active"></td>
  <td><input type="checkbox" class="editable live"></td>
  <td><button class="delete-btn">Delete</button></td>
`;
tbody.appendChild(newRow);
});


document.addEventListener('DOMContentLoaded', function () {
document.querySelectorAll('.filename').forEach(input => {
    input.addEventListener('input', function () {
        const row = input.closest('tr');
        const activeCheckbox = row.querySelector('.active');
        if (input.value.trim() === '') {
            activeCheckbox.checked = false;
        }
    });
  });
});





  document.getElementById('process-btn').addEventListener('click', function () {

    // Show progress bar
  document.getElementById("progress-container").style.display = "block";
  document.getElementById("progress-bar").value = 0;
  document.getElementById("progress-text").innerText = "0%";
  let progressTimeoutId = null;

  // Start polling progress
  function pollProgress() {
    fetch("/progress")
      .then(res => {
          return res.json();
      })
      .then(data => {

        const bar = document.getElementById("progress-bar");
        const text = document.getElementById("progress-text");
        bar.value = data.percent || 0;
        text.innerText = (data.percent || 0) + "% — " + (data.message || "");

        if (data.status === "complete") {
          console.log("Normalization is complete. Injecting DQstats HTML if available.");
          text.innerText = "✅ Complete";

          if (data.dqstats_html) {
            const tbody = document.querySelector("#DQ-table tbody");
            if (tbody) {
              tbody.innerHTML = data.dqstats_html;
              console.log("DQstats updated successfully.");
            } else {
              console.warn("DQ-table tbody not found in DOM.");
            }
          }

          // 🔄 Inject refreshed streamrag table
          fetch('/streamrag_api')
            .then(res => res.json())  // Parse the JSON response
            .then(data => {
              // Extract the 'html' and 'streamrag' from the response
              const html = data.html;
              const streamrag = data.streamrag;

              // Insert the HTML into the table
              const streamTbody = document.querySelector('#streamtab tbody');
              if (streamTbody) {
                streamTbody.innerHTML = html;
              }

              // Now handle the 'streamrag' data (which is likely an object)
              const labels = Object.keys(streamrag);
              const dataPoints = labels.map(label => streamrag[label].Elect);
              const rags = labels.map(label => streamrag[label].RAG);

              console.log("streamtablabels:", labels);
              console.log("streamtabdata:", dataPoints);
              console.log("streamtabrags:", rags);

              // Update the chart
              window.parent.createOrUpdateChart(labels, dataPoints, rags);
            })
            .catch(error => {
              console.error('Error:', error);
            });


          // Stop here; ❌ no further polling
        } else if (data.status === "error") {
          console.error("Error in normalization:", data.message);
          text.innerText = "⚠️ " + (data.message || "Error");
        } else if (data.status === "error") {
          console.error("Error in normalization:", data.message);
          text.innerText = "⚠️ " + (data.message || "Error");

          // Stop polling
          if (progressTimeoutId) {
              clearTimeout(progressTimeoutId);
          }

        } else {
          // Continue polling after 500ms
          progressTimeoutId = setTimeout(pollProgress, 500);
        }
      })
      .catch(err => {
        console.error("Polling error:", err);
      });
  }

  const streamToProcess = prompt("Enter the election name for which you want to import data:");
  if (!streamToProcess) return;

  const normalizedInput = streamToProcess.trim().toLowerCase();
  const rows = document.querySelectorAll('#file-info-tbody tr');
  const formData = new FormData();
  let found = false;
  console.log(`streamtoProcess ${rows}`);

  rows.forEach((row, index) => {
    const election = row.querySelector('.election').value.trim().toLowerCase();
    const active = row.querySelector('.active').checked;
    const order = row.querySelector('.order').value;
    const ftype = row.querySelector('.type').value;
    const purpose = row.querySelector('.purpose').value;
    const fixlevel = row.querySelector('.fixlevel').value;
    const fileInput = row.querySelector('.file-picker');
    const filepathEl = row.querySelector('.file-path');
    const filepath = filepathEl ? filepathEl.value : '';

//      alert('inside active and stream: '+ stream+active );

    if (active && election === normalizedInput) {
      formData.append('election', normalizedInput);

      if (fileInput.files.length > 0) {
        const file = fileInput.files[0];
        formData.append(`files_${index}`, file);  // upload if picked this session
      } else if (filepath) {
        formData.append(`stored_path_${index}`, filepath);  // use stored safe path
//          alert('Filepath found: '+`stored_path_${index}` + filepath);
      } else {
        console.warn(`No file selected or stored path for election '${election}'`);
        return; // skip this row
      }
      console.log(`Row ${index} fileInput.files.length: ${fileInput.files.length}`);
      console.log(`Row ${index} filepath: "${filepath}"`);
      // Append other metadata
      formData.append(`meta_${index}_order`, order);
      formData.append(`meta_${index}_type`, ftype);
      formData.append(`meta_${index}_purpose`, purpose);
      formData.append(`meta_${index}_fixlevel`, fixlevel);
      formData.append(`meta_${index}_election`, election);
      // After metadata is appended


      found = true;
    };
    console.log(`Row election: '${election}', user input: '${normalizedInput}', active: ${active}`);

  });

  if (!found) {
    alert("No matching files found for election: " + streamToProcess);
    return;
  }

  pollProgress();

  fetch('/normalise', {
    method: 'POST',
    body: formData
  })
    .then(response => response.text())
    .then(html => {
      const dqTableBody = document.querySelector('#DQ-table tbody');
      if (dqTableBody) {
        dqTableBody.innerHTML = html;
      }

      // Optionally reload streamtab again after update
      fetch('/streamrag_api')
        .then(res => res.json())  // Parse the JSON response
        .then(data => {
          // Extract the 'html' and 'streamrag' from the response

          const html = data.html;
          const streamrag = data.streamrag;

          // Insert the HTML into the table
          const streamTbody = document.querySelector('#streamtab tbody');
          if (streamTbody) {
            streamTbody.innerHTML = html;
          }

          // Now handle the 'streamrag' data (which is likely an object)
          const labels = Object.keys(streamrag);
          const dataPoints = labels.map(label => streamrag[label].Elect);
          const rags = labels.map(label => streamrag[label].RAG);

          console.log("streamtablabels:", labels);
          console.log("streamtabdata:", dataPoints);
          console.log("streamtabrags:", rags);

          // Update the chart
          window.parent.createOrUpdateChart(labels, dataPoints, rags);
        })
        .catch(error => {
          console.error('Error:', error);
        });
      })
    .catch(error => {
      clearTimeout(progressTimeoutId);
      progressTimeoutId = null;
      console.error('Error:', error);
      alert("Processing error: " + error);
    });
});

document.getElementById('file-info-tbody').addEventListener('click', function (e) {
  if (e.target.classList.contains('file-btn')) {
    const row = e.target.closest('tr');
    const fileInput = row.querySelector('.file-picker');
    fileInput.click();
  }
});

document.getElementById('file-info-tbody').addEventListener('change', function (e) {
  if (e.target.classList.contains('file-picker')) {
    const row = e.target.closest('tr');
    const fileInput = e.target;
    const file = fileInput.files[0];

    if (file) {
      const filenameField = row.querySelector('.filename');
      const filePathField = row.querySelector('.file-path');

      filenameField.value = file.name;
      filePathField.value = file.name;  // Simulated; browsers don’t give real paths

      // Optionally mark as active
      const activeCheckbox = row.querySelector('.active');
      if (activeCheckbox) activeCheckbox.checked = true;
    }
  }
});


</script>
{% endblock map %}
