{% extends "base.html" %}
{% block map %}

<!-- Editable File Information Table -->
<h4 style="text-align: center">Electoral registers, changes and postal voter files</h4>
<h4 style="text-align: center">(Select fix level 3 to upload)</h4>
<button id="add-row-btn">Add Row</button>
<button id="save-btn">Save</button>

<table id="stream-table" border="1">
  <thead>
    <tr>
      <th>Order</th>
      <th>Election</th>
      <th>Territory</th>
      <th>Filename</th>
      <th>Type</th>
      <th>Purpose</th>
      <th>Fixlevel</th>
      <th>Active</th>
      <th>Live</th>
      <th>Delete</th>
    </tr>
  </thead>
  <tbody id="file-info-tbody">
    {% for row in stream_table %}
    <tr>
      <td>
        <input type="number" class="editable order" value="{{ row['order'] }}" style="width: 60px;">
      </td>
      <td>
        <select class="editable election" data-initial="{{ row['election'] }}" data-territory="{{ row['territory'] }}"></select>
      </td>
      <td>
        <input type="text" class="right-cropped territory" value="{{ row['territory'] }}" data-full-territory="{{ row['territory'] }}" readonly>
      </td>
      <td>
        <input type="text" class="editable filename" value="{{ row['filename'] }}" readonly style="width: 300px;">
        <input type="hidden" class="file-path" value="{{ row['file_path'] }}">
        <input type="file" class="file-picker" style="display: none;" accept=".csv,.xlsx">
        <button type="button" class="file-btn">ðŸ“‚</button>
      </td>
      <td>
        <select class="editable type" style="width: 60px;">
          <option value="csv" {% if row['type'] == 'csv' %}selected{% endif %}>csv</option>
          <option value="xlsx" {% if row['type'] == 'xlsx' %}selected{% endif %}>xlsx</option>
          <option value="json" {% if row['type'] == 'json' %}selected{% endif %}>json</option>
        </select>
      </td>
      <td>
        <select class="editable purpose" style="width: 60px;">
          <option value="main" {% if row['purpose'] == 'main' %}selected{% endif %}>main</option>
          <option value="delta" {% if row['purpose'] == 'delta' %}selected{% endif %}>delta</option>
          <option value="avi" {% if row['purpose'] == 'avi' %}selected{% endif %}>avi</option>
          <option value="mark" {% if row['purpose'] == 'mark' %}selected{% endif %}>mark</option>
          <option value="resource" {% if row['purpose'] == 'resource' %}selected{% endif %}>resource</option>
        </select>
      </td>
      <td><input type="number" class="editable fixlevel" value="{{ row['fixlevel'] or 0 }}" style="width: 60px;"></td>
      <td><input type="checkbox" class="editable active" {% if row['active'] and row['filename'].strip() != '' %}checked{% endif %}></td>
      <td><input type="checkbox" class="editable live" {% if row['live'] and row['live'].strip() != '' %}checked{% endif %}></td>
      <td><button class="delete-btn">Delete</button></td>
    </tr>
    {% endfor %}
  </tbody>
</table>

<!-- DATA QUALITY DASHBOARD -->
<div id="streams" class="section">
  <h3 class="centred">DATA QUALITY DASHBOARD</h3>
  <table id="streamtab">
    <thead>
      <tr>
        <th>Election</th>
        <th>Alive</th>
        <th>Files</th>
        <th>Elect</th>
        <th>RAG</th>
        <th>Action</th>
      </tr>
    </thead>
    <tbody>
      {% for key, value in streamrag.items() %}
      <tr>
        <td>{{ key }}</td>
        <td>{{ value['Alive'] }}</td>
        <td>{{ value['Files'] }}</td>
        <td>{{ value['Elect'] }}</td>
        <td>{{ value['RAG'] }}</td>
        <td><button onclick="deactivateElection('{{ key }}')">Deactivate</button></td>
      </tr>
      {% endfor %}
    </tbody>
  </table>
</div>

<!-- Import Table -->
<div id="importTable" class="section">
  <div id="DQ-controls" style="margin-bottom: 10px;">
    <button id="process-btn">LOAD ELECTION</button>
    <button id="reset-btn">RESET</button>
    <div id="progress-container" style="margin-top: 20px; display: none;">
      <label for="progress-bar">Normalization Progress:</label>
      <progress id="progress-bar" value="0" max="100" style="width: 300px;"></progress>
      <span id="progress-text">0%</span>
    </div>
  </div>

  <table id="DQ-table">
    <thead>
      <tr>
        <th>Election</th>
        <th>Filename</th>
        <th>Field</th>
        <th>P0</th>
        <th>P1</th>
        <th>P2</th>
        <th>P3</th>
      </tr>
    </thead>
    <tbody>
      {% for index, row in DQstats.iterrows() %}
      <tr>
        <td>{{ row['Election'] }}</td>
        <td>{{ row['File'] }}</td>
        <td>{{ row['Field'] }}</td>
        <td>
          <label class="maximpact-label">
            <input type="checkbox" class="maximpact-checkbox"{% if row['P0'] == 1 %}checked{% endif %} disabled>
          </label>
        </td>
        <td>
          <label class="maximpact-label">
            <input type="checkbox" class="maximpact-checkbox"{% if row['P1'] == 1 %}checked{% endif %} disabled>
          </label>
        </td>
        <td>
          <label class="maximpact-label">
            <input type="checkbox" class="maximpact-checkbox"{% if row['P2'] == 1 %}checked{% endif %} disabled>
          </label>
        </td>
        <td>
          <label class="maximpact-label">
            <input type="checkbox" class="maximpact-checkbox"{% if row['P3'] == 1 %}checked{% endif %} disabled>
          </label>
        </td>
      </tr>
      {% endfor %}
    </tbody>
  </table>
</div>


<script>



  function deactivateElection(election) {
    if (!confirm(`Are you sure you want to deactivate ${election}?`)) return;

    fetch('/deactivate_stream', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ election: election })
    })
    .then(res => res.json())
    .then(response => {
      if (response.status === 'success') {
        const html = response.html;
        const streamrag = response.streamrag;
        const streamTbody = document.querySelector('#streamtab tbody');
        if (streamTbody) {
          streamTbody.innerHTML = html;
        };
        alert(`Election  ${response.election} successfully deactivated.`);

        window.parent.updateMessages();
      } else {
        alert(`Deactivation Error: ${response.message}`);
      }

    })
    .catch(err => {
      console.error("Deactivation failed:", err);
      alert("An error occurred while deactivating.");
    });
    // Refresh the RAG table
    fetch('/streamrag_api')
      .then(res => res.json())
      .then(data => {
        const html = data.html;
        const streamrag = data.streamrag;
        const streamTbody = document.querySelector('#streamtab tbody');
        if (streamTbody) {
          streamTbody.innerHTML = html;
        }
        window.parent.updateMessages();
        // Now handle the 'streamrag' data (which is likely an object)
        const labels = Object.keys(streamrag);
        const dataPoints = labels.map(label => streamrag[label].Elect);
        const rags = labels.map(label => streamrag[label].RAG);

        console.log("streamtablabels:", labels);
        console.log("streamtabdata:", dataPoints);
        console.log("streamtabrags:", rags);

        // Update the chart
        window.parent.createOrUpdateChart(labels, dataPoints, rags);
      });
  }


function collectTableData() {
  const rows = document.querySelectorAll('#file-info-tbody tr');
  const data = [];

  rows.forEach(row => {
    const rowData = {
      order: parseInt(row.querySelector('.order')?.value || "0"),
      election: row.querySelector('.election')?.value || "",
      territory: row.querySelector('.territory')?.value || "",
      filename: row.querySelector('.filename')?.value || "",
      type: row.querySelector('.type')?.value || "",
      purpose: row.querySelector('.purpose')?.value || "",
      fixlevel: parseInt(row.querySelector('.fixlevel')?.value || "0"),
      active: row.querySelector('.active')?.checked || false,
      file_path: row.querySelector('.file-path')?.value || ""
    };

    console.log("Row Data:", rowData);  // âœ… Log to console
    data.push(rowData);
  });

  return data;
  }


document.getElementById('reset-btn').addEventListener('click', () => {
  if (!confirm("Are you sure you want to reset Elections?")) return;

  fetch('/reset_Elections', { method: 'POST' })
    .then(res => res.json())
    .then(data => {
      alert(data.message);
// ðŸ”„ Inject refreshed streamrag table
    fetch('/streamrag_api')
      .then(res => res.json())  // Parse the JSON response
      .then(data => {
        // Extract the 'html' and 'streamrag' from the response
        const html = data.html;
        const streamrag = data.streamrag;

        // Insert the HTML into the table
        const streamTbody = document.querySelector('#streamtab tbody');
        if (streamTbody) {
          streamTbody.innerHTML = html;
        }
        window.parent.updateMessages();
      })
      .catch(error => {
        console.error('Error:', error);
      });
    })
    .catch(err => alert("Error resetting elections."));
});


    document.getElementById('save-btn').addEventListener('click', function () {
      const tableData = collectTableData();
      console.log(tableData);
      fetch('/save_stream_table', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ data: tableData })
      })
      .then(res => res.json())
      .then(data => alert("Saving tableData:"+data.message))
      .catch(err => alert("Error saving: " + err));
    });

document.getElementById('file-info-tbody').addEventListener('click', function (e) {
  if (e.target.classList.contains('file-btn')) {
         const td = e.target.closest('td');
         const row = td.closest('tr');
         const fileInput = td.querySelector('.file-picker');
         const activeCheckbox = row.querySelector('.active');
         const filenameField = td.querySelector('.filename');
         const filePathField = td.querySelector('.file-path');

         fileInput.click();

         fileInput.onchange = async function () {
             if (fileInput.files.length > 0) {
                 const file = fileInput.files[0];
                 const formData = new FormData();
                 formData.append('file', file);

                 try {
                     const res = await fetch('/upload_file', {
                         method: 'POST',
                         body: formData
                     });
                     const result = await res.json();

                     if (result.error) {
                         alert("Upload error: " + result.error);
                         return;
                     }
                     filenameField.value = file.name;
                     filePathField.value = result.path;


                     filenameField.value = file.name;
                     filePathField.value = result.path;  // backend returns full saved path
                     // Auto-check active if filename is set
                       if (file.name.trim() == '') {
                         activeCheckbox.checked = false;
                       }
                 } catch (err) {
                     alert("Failed to upload file: " + err);
                 }
             }
         };
     }

     // Unchecking active flag resets the row
     if (e.target.classList.contains('active')) {
         const checkbox = e.target;
         const row = checkbox.closest('tr');

         if (!checkbox.checked) {
           // ðŸ”½ Auto-trigger file picker
           const fileInput = newRow.querySelector('.file-picker');
           if (fileInput) {
             fileInput.click(); // Opens file dialog

             // Optional: auto-handle file upload if needed
             fileInput.onchange = async function () {
               const filenameField = newRow.querySelector('.filename');
               const filePathField = newRow.querySelector('.file-path');
               const activeCheckbox = newRow.querySelector('.active');

               if (fileInput.files.length > 0) {
                 const file = fileInput.files[0];
                 const formData = new FormData();
                 formData.append('file', file);

                 try {
                   const res = await fetch('/upload_file', {
                     method: 'POST',
                     body: formData
                   });

                   const result = await res.json();

                   if (result.error) {
                     alert("Upload error: " + result.error);
                     return;
                   }

                   filenameField.value = file.name;
                   filePathField.value = result.path;
                   if (file.name.trim() !== '') {
                     activeCheckbox.checked = true;
                   }
                 } catch (err) {
                   alert("Failed to upload file: " + err);
                 }
               }
             };
           }
         }
     }

  if (e.target.classList.contains('delete-btn')) {
    e.target.closest('tr').remove();
  }
});

document.getElementById('add-row-btn').addEventListener('click', function () {
  const tbody = document.getElementById('file-info-tbody');
  const newRow = document.createElement('tr');

  newRow.innerHTML = `
      <td>
        <input type="number" class="editable order" value="1" style="width: 60px;">
      </td>
      <td>
        <select class="editable election"
                data-initial=""
                data-territory=""
                data-new="true">
        </select>
      </td>
      <td>
        <input type="text" class="right-cropped territory" value="" readonly>
      </td>
      <td>
      <input type="text" class="editable filename" style="width: 300px;" readonly>
      <input type="hidden" class="file-path" value="">
      <input type="file" class="file-picker" style="display: none;" accept=".csv,.xlsx">
      <button type="button" class="file-btn">ðŸ“‚</button>
    </td>
    <td>
      <select class="editable type" style="width: 60px;">
        <option value="csv">csv</option>
        <option value="xlsx">xlsx</option>
        <option value="json">json</option>
      </select>
    </td>
    <td>
      <select class="editable purpose" style="width: 60px;">
        <option value="main">main</option>
        <option value="delta">delta</option>
        <option value="avi">avi</option>
        <option value="mark">mark</option>
        <option value="resource">resource</option>
      </select>
    </td>
    <td><input type="number" class="editable fixlevel" value="0" style="width: 60px;"></td>
    <td><input type="checkbox" class="editable active"></td>
    <td><input type="checkbox" class="editable live"></td>
    <td><button class="delete-btn">Delete</button></td>
  `;

  tbody.appendChild(newRow);

  populateElectionDropdowns();

  document.querySelectorAll('.editable.election').forEach(select => {
  select.addEventListener('change', function () {
    const selectedOption = this.options[this.selectedIndex];
    const territory = selectedOption.dataset.territory || this.dataset.territory || '';
    this.setAttribute('data-territory', territory);

    const inputRow = this.closest('tr') || this.closest('.row'); // adjust to your structure
    const territoryInput = inputRow.querySelector('.territory');

    if (territoryInput) {
      const parts = territory.split('/');
      const last = parts.pop();
      territoryInput.value = last || '';
      territoryInput.setAttribute('data-full-territory', territory); // optional
    }
  });
});

  // ðŸ”½ Auto-trigger file picker
  const fileInput = newRow.querySelector('.file-picker');
  if (fileInput) {
    fileInput.click(); // Opens file dialog

    // Optional: auto-handle file upload if needed
    fileInput.onchange = async function () {
      const filenameField = newRow.querySelector('.filename');
      const filePathField = newRow.querySelector('.file-path');
      const activeCheckbox = newRow.querySelector('.active');

      if (fileInput.files.length > 0) {
        const file = fileInput.files[0];
        const formData = new FormData();
        formData.append('file', file);

        try {
          const res = await fetch('/upload_file', {
            method: 'POST',
            body: formData
          });

          const result = await res.json();

          if (result.error) {
            alert("Upload error: " + result.error);
            return;
          }

          filenameField.value = file.name;
          filePathField.value = result.path;
          if (file.name.trim() !== '') {
            activeCheckbox.checked = true;
          }
        } catch (err) {
          alert("Failed to upload file: " + err);
        }
      }
    };
  }
});

function populateElectionDropdowns() {
const parentSelect = window.parent.document.getElementById("streams");
const electionNames = Array.from(parentSelect.options).map(opt => opt.value);
console.log(`__Stream_Processing elections ${electionNames} drop down from parentSelect:`,  parentSelect.options)
// ðŸ†• Access the election-to-territory mapping
const mapfilesSelect = window.parent.document.getElementById("mapfiles");
const territoryEL =
    mapfilesSelect?.options?.length
        ? mapfilesSelect.options[mapfilesSelect.options.length - 1].value
        : null;

const allElectionDropdowns = document.querySelectorAll('.editable.election');

allElectionDropdowns.forEach(select => {
  const currentValue = select.getAttribute('data-initial');
  const currentTerritory = select.getAttribute('data-territory');
  const isNewRow = select.getAttribute('data-new') === 'true';

  select.innerHTML = '';  // Clear existing options

  electionNames.forEach(electionName => {
    const option = document.createElement('option');
    option.value = electionName;
    option.textContent = electionName;

    // ðŸ§  Add data-territory to each option

    option.dataset.territory = territoryEL || '';


    if (electionName === currentValue) {
      option.selected = true;
    }

    select.appendChild(option);
  });

  // If current value is missing from the list
  if (currentValue && !electionNames.includes(currentValue)) {
    const missingOption = document.createElement('option');
    missingOption.value = currentValue;
    missingOption.textContent = currentValue + " (not found)";
    missingOption.dataset.territory = currentTerritory || '';
    missingOption.selected = true;
    select.appendChild(missingOption);
  }
});

console.log("âœ… Populated election dropdowns with data-territory values.");
}

  document.addEventListener('DOMContentLoaded', function () {


    populateElectionDropdowns();

  document.querySelectorAll('.filename').forEach(input => {
      input.addEventListener('input', function () {
          const row = input.closest('tr');
          const activeCheckbox = row.querySelector('.active');
          if (input.value.trim() === '') {
              activeCheckbox.checked = false;
          }
      });
    });

    document.querySelectorAll('.editable.election').forEach(select => {
    select.addEventListener('change', function () {
      const selectedOption = this.options[this.selectedIndex];
      const territory = selectedOption.dataset.territory || this.dataset.territory || '';
      this.setAttribute('data-territory', territory);

      const inputRow = this.closest('tr') || this.closest('.row'); // adjust to your structure
      const territoryInput = inputRow.querySelector('.territory');

      if (territoryInput) {
        const parts = territory.split('/');
        const last = parts.pop();
        territoryInput.value = last || '';
        territoryInput.setAttribute('data-full-territory', territory); // optional
      }
    });
  });

  });





      document.getElementById('process-btn').addEventListener('click', function () {

        // Show progress bar
      document.getElementById("progress-container").style.display = "block";
      document.getElementById("progress-bar").value = 0;
      document.getElementById("progress-text").innerText = "0%";
      let progressTimeoutId = null;

      // Start polling progress
      function pollProgress() {
        fetch("/progress")
          .then(res => {
              return res.json();
          })
          .then(data => {

            const bar = document.getElementById("progress-bar");
            const text = document.getElementById("progress-text");
            bar.value = data.percent || 0;
            text.innerText = (data.percent || 0) + "% â€” " + (data.message || "");

            if (data.status === "complete") {
              console.log("Normalization is complete. Injecting DQstats HTML if available.");
              text.innerText = "âœ… Complete";

              if (data.dqstats_html) {
                const tbody = document.querySelector("#DQ-table tbody");
                if (tbody) {
                  tbody.innerHTML = data.dqstats_html;
                  console.log("DQstats updated successfully.");
                } else {
                  console.warn("DQ-table tbody not found in DOM.");
                }
              }

              const html = data.html;
              const streamrag = data.streamrag;
              const streamTbody = document.querySelector('#streamtab tbody');
              if (streamTbody) {
                streamTbody.innerHTML = html;
              }
              // Now handle the 'streamrag' data (which is likely an object)
              const labels = Object.keys(streamrag);
              const dataPoints = labels.map(label => streamrag[label].Elect);
              const rags = labels.map(label => streamrag[label].RAG);

              console.log("streamtablabels:", labels);
              console.log("streamtabdata:", dataPoints);
              console.log("streamtabrags:", rags);

              // Update the chart
              window.parent.createOrUpdateChart(labels, dataPoints, rags);


              // Stop here; âŒ no further polling
            } else if (data.status === "error") {
              console.error("Error in normalization:", data.message);
              text.innerText = "âš ï¸ " + (data.message || "Error");
            } else if (data.status === "error") {
              console.error("Error in normalization:", data.message);
              text.innerText = "âš ï¸ " + (data.message || "Error");

              // Stop polling
              if (progressTimeoutId) {
                  clearTimeout(progressTimeoutId);
              }

            } else {
              // Continue polling after 500ms
              progressTimeoutId = setTimeout(pollProgress, 500);
            }
          })
          .catch(err => {
            console.error("Polling error:", err);
          });
      }

      const streamToProcess = prompt("Enter the election name for which you want to import data:");
      if (!streamToProcess) return;

      const normalizedInput = streamToProcess.trim().toLowerCase();
      const rows = document.querySelectorAll('#file-info-tbody tr');
      const formData = new FormData();
      let found = false;
      console.log(`streamtoProcess ${rows}`);

      rows.forEach((row, index) => {
        const election = row.querySelector('.election').value.trim().toLowerCase();
        const territory = row.querySelector('.territory').value;
        const active = row.querySelector('.active').checked;
        const order = row.querySelector('.order').value;
        const ftype = row.querySelector('.type').value;
        const purpose = row.querySelector('.purpose').value;
        const fixlevel = row.querySelector('.fixlevel').value;
        const fileInput = row.querySelector('.file-picker');
        const filepathEl = row.querySelector('.file-path');
        const filepath = filepathEl ? filepathEl.value : '';

    //      alert('inside active and stream: '+ stream+active );
        console.log(`Row ${index} filepath: "${filepath} filepathEl: "${filepathEl}"` ); // Add this
        if (active && election === normalizedInput) {
          formData.append('election', normalizedInput);

          if (fileInput.files.length > 0) {
            const file = fileInput.files[0];
            formData.append(`files_${index}`, file);  // upload if picked this session
          } else if (filepath) {
            formData.append(`stored_path_${index}`, filepath);  // use stored safe path
    //          alert('Filepath found: '+`stored_path_${index}` + filepath);
          } else {
            console.warn(`No file selected or stored path for election '${election}'`);
            return; // skip this row
          }
          console.log(`Row ${index} fileInput.files.length: ${fileInput.files.length}`);
          console.log(`Row ${index} filepath: "${filepath}"`);
          // Append other metadata
          formData.append(`meta_${index}_order`, order);
          formData.append(`meta_${index}_type`, ftype);
          formData.append(`meta_${index}_purpose`, purpose);
          formData.append(`meta_${index}_fixlevel`, fixlevel);
          formData.append(`meta_${index}_election`, election);
          // After metadata is appended


          found = true;
        };
        console.log(`Row election: '${election}', user input: '${normalizedInput}', active: ${active}`);

      });

      if (!found) {
        alert("No matching files found for election: " + streamToProcess);
        return;
      }

      pollProgress();

      fetch('/normalise', {
        method: 'POST',
        body: formData
      })
        .then(response => response.text())
        .then(html => {
          const dqTableBody = document.querySelector('#DQ-table tbody');
          if (dqTableBody) {
            dqTableBody.innerHTML = html;
          }

          // Optionally reload streamtab again after update
          fetch('/streamrag_api')
            .then(res => res.json())  // Parse the JSON response
            .then(data => {
              // Extract the 'html' and 'streamrag' from the response

              const html = data.html;
              const streamrag = data.streamrag;

              // Insert the HTML into the table
              const streamTbody = document.querySelector('#streamtab tbody');
              if (streamTbody) {
                streamTbody.innerHTML = html;
              }

              // Now handle the 'streamrag' data (which is likely an object)
              const labels = Object.keys(streamrag);
              const dataPoints = labels.map(label => streamrag[label].Elect);
              const rags = labels.map(label => streamrag[label].RAG);

              console.log("streamtablabels:", labels);
              console.log("streamtabdata:", dataPoints);
              console.log("streamtabrags:", rags);

              // Update the chart
              window.parent.createOrUpdateChart(labels, dataPoints, rags);
            })
            .catch(error => {
              console.error('Error:', error);
            });
          })
        .catch(error => {
          clearTimeout(progressTimeoutId);
          progressTimeoutId = null;
          console.error('Error:', error);
          alert("Processing error: " + error);
        });
    });








</script>
{% endblock map %}
