{% extends "base.html" %}
{% block map %}
<div id="mapwin" class="innertube">
    <iframe id="iframe1" src= {{ url_for('thru',path=mapfile) }} width="1200" height="800" onload="refreshTableData('nodelist_xref')"> </iframe>
</div>
<style>
  /* Container to align label and switch */
  .toggle-container {
    display: flex;
    align-items: center;
    gap: 12px; /* space between label and switch */
    font-family: sans-serif;
    margin: 10px 0;
  }

  .toggle-label {
    font-size: 16px;
    color: #333;
  }

  /* Switch styling */
  .switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 28px;
  }

  .switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }

  .slider {
    position: absolute;
    cursor: pointer;
    top: 0; left: 0;
    right: 0; bottom: 0;
    background-color: #ccc;
    transition: 0.4s;
    border-radius: 28px;
  }

  .slider:before {
    position: absolute;
    content: "";
    height: 22px;
    width: 22px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: 0.4s;
    border-radius: 50%;
  }

  input:checked + .slider {
    background-color: #4CAF50;
  }

  input:checked + .slider:before {
    transform: translateX(22px);
  }
</style>
<script >
  // Listen to message from child window
  const pessages = [];
  var pack = JSON.parse('{{ get_flashed_messages()|tojson|safe }}');

  for (let x in pack) {
  pessages.push(pack[x]);
  };

  var iframeEl = document.getElementById('iframe1');

  function bindEvent( element, eventName, eventHandler) {
   if (element.addEventListener){
       element.addEventListener(eventName, eventHandler, false);
   } else if (element.attachEvent) {
       element.attachEvent('on' + eventName, eventHandler);
   };
  };

  bindEvent( window, 'message', function (e) {
    pessages.pop();
    pessages.push(e.data);
    var logWindow = document.getElementById("logwin");
    var li = document.createElement("li");
    li.appendChild(document.createTextNode(e.data));
    logWindow.appendChild(li);
    logWindow.scrollTop = logWindow.scrollHeight;
      });



</script>
{% endblock map %}

{% block log %}

<div id="logwin" class="innertube">
  <h3>elecTrek flash messages: </h3>
  {% with messages = get_flashed_messages() %}
  {% if messages %}
    <ul class="flashes">
      {% for message in messages %}
        <li>{{ message }}</li>
      {% endfor %}
    </ul>
  {% endif %}
{% endwith %}
		<h3>elecTrek status messages: </h3>
      <ul class="flashes" >
      {% for pessage in pessages %}
        <li> {{ pessage  }}</li>
      {% endfor %}
      </ul>

</div>
{% endblock log %}


{% block nav %}
<div id="nav" >
  <h3>Election Dashboard</h3>
  <ul class="centred" >user: {{ session['username'] }}</ul>
  <ul class="nav nav-tabs" id="election-tabs">
    {% for election_name in ELECTIONS %}
      <li class="nav-item position-relative tab-item">
        <button class="nav-link election-tab {% if election_name == current_election %}active{% endif %}"
                data-election="{{ election_name }}"
                onclick="selectElection('{{ election_name }}')">
          {{ election_name }}
        </button>
        <span class="delete-tab-btn"
              data-election="{{ election_name }}"
              onclick="deleteElection('{{ election_name }}')">√ó</span>
      </li>
    {% endfor %}
    <li class="nav-item">
      <button class="nav-link" id="add-election-tab" style="font-weight: bold;" onclick="addElection()">ÔºãNEW</button>
    </li>
  </ul>


      <div id="constants-container">
      <ul>
        <li class="righted">
          <select class="righted"name="streams" id="streams" ></select><br>
      </li>
      <li class="righted">
        Type of Election: <select class="righted"name="territories" id="territories"></select><br>
      </li>
      <li class="righted">
        Territory: <input class="righted" type="text" name="territory" id="territory" readonly><br>
      </li>
      <li class="righted">
      Party selected: <select class="righted" name="yourparty" id="yourparty"></select><br>
      </li>
      <li class="righted">
      Walk Size: <input class="righted" type="number" min="100" max="500" step="50" name="walksize" id="walksize" /><br>
      </li>
      <li class="righted">
      Team Size: <input class="righted" type="number" min="1" max="25" step="1" name="teamsize" id="teamsize" /><br>
      </li>
      <li class="righted">
      GOTV: <input class="righted" type="number" id="GOTV" name="GOTV" min="0.01" max="0.99" step="0.01"  />
      </li>
      <li class="righted">
        <div class="toggle-container">
          <span class="toggle-label">Accumulate: </span>
          <label class="switch">
            <input type="checkbox" id="accumulate" name="accumulate" onchange="handleToggle(this)">
            <span class="slider"></span>
          </label>
        </div>
      </li>
      <li class="righted">
      Bookmarks: <select class="righted" name="mapfiles" id="mapfiles" ></select><br>
      </li>
      <li class="righted">
        <label id="resources-toggle" style="cursor: pointer;">Resources ‚¨á</label>
        <div id="resources-container" style="display: none; position: absolute; background: white; border: 1px solid #ccc; padding: 5px;">
          <select name="resources" id="resources" multiple size="5"></select>
        </div>
      </li>
      <li class="righted" >
      Candidate: <select class="righted" name="candidate" id="candidate" ></select><br>
        </li>
      <li class="righted" >
      Campaign Mgr: <select class="righted" name="campaignMgr" id="campaignMgr" ></select><br>
      </li>
      <li class="righted" >
      Email: <input class="righted" name="campaignMgremail" id="campaignMgremail" readonly></input><br>
      </li>
      <li class="righted" >
      Mobile: <select class="righted" name="mobile" id="mobile" ></select><br>
      </li>
      <li class="righted" >
      Prev.Party: <select class="righted" name="previousParty" id="previousParty" disabled></select><br>
      </li>
      <li class="righted">
          Date of election:
          <input
          class="righted"
          type="date"
          id="electiondate"
          name="electiondate"
          />
      </li>
      </ul>
</div>
        <div class = "grid-container">
          <div class="grid-item">
          <button type="button" id="update-territory-btn" class="small_btn">BOOKMARK<br>TERRITORY</button>
          </div>
            <div class="grid-item">
              <button type = "button" id = "b1" class = "small_btn" onclick="setActionForm('filelist',filelist='maps')">Boundary<br>Maps</button>
            </div>
            <div class="grid-item">
              <button type = "button" id = "b2" class = "small_btn" onclick="window.open('/election-report', '_blank')">ELECTIONS<br>REPORT</button>
            </div>
            <div class="grid-item">
              <button type="button" id="b3" class="small_btn" >ELECTORAL<br>REGISTERS</button>
            </div>
            <div class="grid-item">
              <button type = "button" id = "b4" class = "small_btn">ACTIVITY<br>DELIVERY</button>
            </div>
            <div class="grid-item">
              <button type = "button" id = "b5" class = "small_btn">CAMPAIGN PROGRESS</button>
            </div>
            <div class="grid-item">
              <button type = "button" id = "b9" class = "small_btn">RESOURCING</button>
            </div>
            <div class="grid-item">
              <button type = "button" id = "b6" class = "small_btn">VOTER<br>TELLING</button>
            </div>
            <div class="grid-item">
              <button type = "button" id = "b7" class = "small_btn" >ELECTOR<br>SEARCH</button>
            </div>
            <div class="grid-item">
              <button type = "button" id = "b8" class = "small_btn" >BROWSE<br>TERRITORY</button>
            </div>
            <div class="grid-item">
              <button type = "button" id = "logout-button" class = "small_btn" >LOGOUT</button>
            </div>

          </div>
    <div id="chartContainer" style="width: 300px; height: 300px; position: relative;">
      <canvas id="streamChart"></canvas>
    </div>
  </div>
{% endblock nav %}
{% block captains %}

<div id="tabletitle" class="innertube">
  <span id="selectedTitle">Table Details</span>
  <select id="tableSelector">
    {% for key, value in table_types.items() %}
    <option value="{{ key }}">{{ value }}</option>
  {% endfor %}
  </select>

</div>


<div id="datawin" class="innertube">
  <table id="captains-table">
    <thead></thead>
    <tbody style="height: 70px"></tbody>
  </table>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>

<script>
function fetchTableData(tableName) {
  const VCO = {
    O: "brown", R: "cyan", C: "blue", S: "red",
    LD: "yellow", G: "limegreen", I: "indigo",
    PC: "darkred", SD: "orange", Z: "lightgray",
    W: "white", X: "darkgray"
  };

  const table = document.getElementById("captains-table");
  const tabtitle = document.getElementById("selectedTitle");
  const tabletitle = document.getElementById("tabletitle");

  if (!table || !tabtitle) {
    console.error("‚ùå Required DOM elements not found: #captains-table or #selectedTitle");
    return;
  }

  const tabhead = table.querySelector("thead");
  const tabbody = table.querySelector("tbody");

  if (!tabhead || !tabbody) {
    console.error("‚ùå Table structure invalid: missing <thead> or <tbody>");
    return;
  }

  console.log(`üì• Fetching data for table: ${tableName}`);

  fetch(`/get_table/${tableName}`, {
    method: "GET",
    headers: { "Content-Type": "application/json" },
    credentials: "same-origin"
  })
  .then(response => {
    if (!response.ok) throw new Error(`Server returned ${response.status}`);
    return response.json();
  })
  .then(data => {
    if (!Array.isArray(data) || data.length < 3) {
      console.error("‚ùå Invalid data format received:", data);
      return;
    }

    const [columnHeaders, rows, title] = data;

    // Clear and set title
    tabtitle.textContent = title;
    tabhead.innerHTML = "";
    tabbody.innerHTML = "";

    // Create table head
    const headRow = document.createElement("tr");
    const checkboxHeader = document.createElement("th");
    checkboxHeader.textContent = "?";
    headRow.appendChild(checkboxHeader);

    columnHeaders.forEach(header => {
      const th = document.createElement("th");
      th.textContent = header.toUpperCase();
      headRow.appendChild(th);
    });
    tabhead.appendChild(headRow);

    // Try to get the current party selector if it exists
    const yourpartyEl = document.getElementById("yourparty");
    const selectedParty = yourpartyEl ? yourpartyEl.value : null;

    rows.forEach(record => {
      const row = document.createElement("tr");

      // Add checkbox cell
      const checkboxCell = document.createElement("td");
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.name = "selectRow[]";
      checkbox.classList.add("selectRow");
      checkboxCell.appendChild(checkbox);
      row.appendChild(checkboxCell);

      columnHeaders.forEach(header => {
        const cell = document.createElement("td");
        const value = record[header] !== undefined ? record[header] : "";

        cell.textContent = value;

        // Highlight cell based on party
        if (selectedParty && header === selectedParty) {
          const color = VCO[selectedParty] || "inherit";
          cell.style.backgroundColor = color;
        }

        row.appendChild(cell);
      });

      tabbody.appendChild(row);
    });

    console.log(`‚úÖ Table "${tableName}" populated with ${rows.length} rows.`);
  })
  .catch(error => {
    console.error("‚ùå Error fetching table data:", error);
  });
}


  function handleToggle(el) {
    if (el.checked) {
      console.log("Switch is ON");
    } else {
      console.log("Switch is OFF");
    }
  }
</script>

<script>

  function changeIframeSrc(newurl) {
    var msg = "Retrieving area "+newurl;
    var logWindow = document.getElementById("logwin");
    var li = document.createElement("li");
    li.appendChild(document.createTextNode(msg));
    logWindow.appendChild(li);
    logWindow.scrollTop = logWindow.scrollHeight;
    document.getElementById("iframe1").src = newurl;
      };

  function toUpperCase(str) {
    return str.replace(
      /\w\S*/g,
      text => text.charAt(0).toUpperCase() + text.substring(1).toUpperCase()
    );
  };

  function refreshTableData(selectedTable) {
    window.parent.postMessage({
    type: "update-table",
    stable: selectedTable
    }, "*"); // Replace * with specific origin if needed
  }

  window.addEventListener("message", function(event) {
    // optionally check event.origin === "https://yourdomain.com"
    if (event.data.type === "update-table") {
        const stable = document.getElementById(event.data.stable);
        if (stable) {
          console.log("Received message to updateTable: " + event.data.stable);
            fetchTableData(stable);
        }
    }
});

function subending(filename, ending) {
  const endings = [
    ".XLSX", ".xlsx", ".CSV", ".csv",
    "-PRINT.html", "-MAP.html", "-WALKS.html",
    "-ZONES.html", "-PDS.html", "-DIVS.html", "-WARDS.html"
  ];

  let stem = filename;

  for (const suffix of endings) {
    if (filename.endsWith(suffix)) {
      stem = filename.slice(0, -suffix.length);
      break;
    }
  }

  const result = stem + ending;
  console.log(`____Subending test: from ${filename} to ${result}`);
  return result;
}

  const tableSelector = document.getElementById("tableSelector");
  if (tableSelector) {
    tableSelector.addEventListener("change", e => {
      const selectedTable = e.target.value;
      fetchTableData(selectedTable);
      console.log("selectedTable:"+selectedTable);
    });
  }


  document.getElementById("logout-button").addEventListener("click", function() {
  window.location.href = "/logout";
  });

  document.getElementById("b4").addEventListener("click", function() {
  changeIframeSrc("{{ url_for('leafletting') }}");
  });

  document.getElementById("b9").addEventListener("click", function() {
      changeIframeSrc("{{ url_for('telling') }}");
  });


  document.getElementById("b7").addEventListener("click", function() {
  changeIframeSrc("{{ url_for('search') }}");
  });


  document.getElementById("b5").addEventListener("click", function() {
    changeIframeSrc("{{ url_for('kanban') }}");
  });

  document.getElementById("b6").addEventListener("click", function() {
  changeIframeSrc("{{ url_for('telling') }}");
});


  // Handle the "Back to Main" button click
  document.getElementById("b8").addEventListener("click", function() {
      // Change the iframe src to the stream processing input page
      changeIframeSrc("{{ url_for('dashboard') }}");
  });

  // Handle the "Electoral Roll" button click
  document.getElementById("b3").addEventListener("click", function() {
      // Change the iframe src to the stream processing input page
    changeIframeSrc("{{ url_for('stream_input') }}");
  });

  let streamChart = null;

  function createOrUpdateChart(labels, data, rags) {
    const ragColors = {
      red: 'rgba(255, 99, 132, 0.9)',
      amber: 'rgba(255, 159, 64, 0.9)',
      limegreen: 'rgba(50, 205, 50, 0.9)'
    };

    const backgroundColors = rags.map(rag => ragColors[rag]);

    // Get canvas element safely in case this is triggered late
    const canvas = document.getElementById('streamChart');
    if (!canvas) {
      console.error('streamChart canvas not found.');
      return;
    }

    const ctx = canvas.getContext('2d');

    if (streamChart) {
      // Update existing chart
      streamChart.data.labels = labels;
      streamChart.data.datasets[0].data = data;
      streamChart.data.datasets[0].backgroundColor = backgroundColors;
      streamChart.update();
    } else {
      // First-time chart creation
      Chart.register(ChartDataLabels); // Only needed once
      streamChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: labels,
          datasets: [{
            label: 'Electors in Stream',
            data: data,
            backgroundColor: backgroundColors,
            borderColor: '#fff',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            title: {
              display: true,
              text: 'Stream Loading Status'
            },
            datalabels: {
              color: '#000',
              font: { size: 14, weight: 'bold' },
              formatter: (value) => value.toLocaleString()
            }
          }
        },
        plugins: [ChartDataLabels]
      });
    }
  };

  function updateChart(newLabels, newData, newRags) {
    const ragColors = {
      red: 'rgba(255, 99, 132, 0.2)',
      amber: 'rgba(255, 159, 64, 0.2)',
      green: 'rgba(75, 192, 192, 0.2)'
    };

    if (!streamChart) {
      console.warn("Chart not initialized.");
      return;
    }

    streamChart.data.labels = newLabels;
    streamChart.data.datasets[0].data = newData;
    streamChart.data.datasets[0].backgroundColor = newRags.map(rag => ragColors[rag] || 'gray');

    streamChart.update();
  };

async function fetchAndUpdateChart() {
  try {
    const response = await fetch('/streamrag_api');
    const receiveddata = await response.json();
    const streamrag = receiveddata.streamrag
    const html = receiveddata.html

    const labels = Object.keys(streamrag);
    const data = labels.map(label => streamrag[label].Elect);
    const rags = labels.map(label => streamrag[label].RAG);

    createOrUpdateChart(labels, data, rags);
  } catch (error) {
    console.error('Failed to fetch streamrag data:', error);
  }
};

  function updateConstantsUI(constants, options) {
    console.log(`Update to constants: ${Object.keys(constants)} : ${Object.entries(options)}`);
    Object.entries(constants).forEach(([key, value]) => {
      const el = document.getElementById(key);
      if (!el) return;

      const optsObj = options[key] || {};
      el.innerHTML = ""; // Clear current options
      if (options[key] && typeof options[key] === 'object') {
          console.log(`Update to constant: ${key} ${constants[key]} :`, Object.entries(options[key]));
        } else {
          console.log(`Update to constant: ${key} ${constants[key]} : (no options available)`);
        }

      if (el.tagName === "SELECT") {

        if (key === "resources") {
          // Multi-select for resources
          Object.entries(options.resources || {}).forEach(([code, person]) => {
            const option = document.createElement("option");
            option.value = code;
            option.textContent = `${person.Firstname} ${person.Surname}`;
            if (Array.isArray(value) && value.includes(code)) {
              option.selected = true;
            }
            el.appendChild(option);
          });

        } else if (key === "candidate" || key === "campaignMgr") {
          // Candidate/compaignMgr filtered by selected resources
          const selectedResources = Array.isArray(constants.resources) ? constants.resources : [];
          selectedResources.forEach(code => {
            const person = options.resources?.[code];
            if (person) {
              const option = document.createElement("option");
              const email = document.getElementById("campaignMgremail");
              option.value = code;
              option.textContent = `${person.Firstname} ${person.Surname}`;
              if (value === code) { option.selected = true;
                 email.value = `${person.campaignMgremail}`;
               };
              el.appendChild(option);
            }
          });

        } else if (key === "mapfiles") {
          // ‚úî Correct mapfiles handling
          if (Array.isArray(value)) {
            value.forEach((mapPath, index) => {
              const o = document.createElement("option");
              o.value = mapPath;
              o.textContent = `Map ${index + 1}: ${mapPath.split("/").pop()}`;
              if (index === value.length - 1) {
                o.selected = true;
              }
              el.appendChild(o);
            });
          }

          // Add listener to change iframe when user selects
          el.onchange = () => {
            const selectedMap = el.value;
            console.log("üó∫Ô∏è Selected map:", selectedMap);
            if (selectedMap) {
              changeIframeSrc(`/thru/${selectedMap}`);
            }
          };

        } else if (key === "streams") {
          // Do nothing as streams is populated elsewhere
        }
         else {
          // Generic SELECT fields C: Conservative , W:Westminster etc
          Object.entries(optsObj).forEach(([optValue, optLabel]) => {
            const o = document.createElement("option");
            o.value = optValue;
            o.textContent = `${optValue}: ${optLabel}`;
            if (optValue === value) o.selected = true;
            el.appendChild(o);
          });
        }
      } else {
        // Non-SELECT elements
        el.value = value;
      }

      // General input handler (select, input, etc.)
      el.oninput = () => {
        let newVal = el.value;
        if (el.type === "number") newVal = parseFloat(newVal);
        if (el.type === "checkbox") newVal = el.checked;
        if (el.multiple) newVal = Array.from(el.selectedOptions).map(opt => opt.value);

        fetch("/set-constant", {
          method: "POST",
          credentials: 'same-origin',
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            election: document.querySelector(".election-tab.active")?.dataset.election || "",
            name: key,
            value: newVal
          })
        })
        .then(res => res.json())
        .then(resp => {
          if (resp.success) {
//            fetchTableData('nodelist_xref');
          } else {
            alert("Failed to update: " + resp.error);
          }
        });
      };
    });
    attachListenersToConstantFields(constants);
  }


  function selectElection(electionName) {
    // Remove 'active' from all tabs
    document.querySelectorAll(".election-tab").forEach(tab => {
      tab.classList.remove("active");
    });

    // Add 'active' to the clicked tab
    const clickedTab = Array.from(document.querySelectorAll(".election-tab"))
      .find(tab => tab.dataset.election === electionName);

    if (clickedTab) {
      clickedTab.classList.add("active");
      clickedTab.classList.add("nav-link.active");
    }

    // Proceed with backend election switch
    fetch("/set-election", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      credentials: "same-origin",
      body: JSON.stringify({ election: electionName })
    })
    .then(res => res.json())
    .then(data => {
      // Update constants UI
      updateConstantsUI(data.constants, data.options);

      // Extract mapfile from the list
      const mapfile = data.constants.territory;

      if (mapfile) {
        changeIframeSrc(`/thru/${mapfile}`);
        console.log(`New mapfile loaded: /thru/${mapfile}`);
      }

      fetchTableData('nodelist_xref');
    });
  }



  function syncStreamsSelectWithTabs() {
      const tabs = document.querySelectorAll('.election-tab');
      const streamsSelect = document.getElementById('streams');

      // Clear existing options
      streamsSelect.innerHTML = '';

      // Add each tab as an option
      tabs.forEach(tab => {
          const election = tab.dataset.election;
          const option = document.createElement('option');
          option.value = election;
          option.textContent = `Election ${election}`;
          streamsSelect.appendChild(option);
      });

      // Set the selected option to match the active tab
      const activeTab = document.querySelector('.election-tab.active');
      if (activeTab) {
          streamsSelect.value = activeTab.dataset.election;
      }
  }


  function deleteElection(electionName) {
    if (!confirm(`Delete "${electionName}"? This cannot be undone.`)) return;

    fetch("/delete-election", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      credentials: "same-origin",
      body: JSON.stringify({ election: electionName })
    })
    .then(res => res.json())
    .then(resp => {
      if (resp.success && resp.electiontabs_html) {
        document.getElementById("election-tabs").innerHTML = resp.electiontabs_html;
        fetchTableData('nodelist_xref');
        syncStreamsSelectWithTabs();
        // ‚úÖ All onclick bindings are preserved because they come from server-rendered HTML
      } else {
        alert("Could not delete election: " + (resp.error || "Unknown error"));
      }
    });
  }

  function addElection() {
    const newName = prompt("Enter name for new election:");
    if (!newName) return;

    fetch("/add-election", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      credentials: "same-origin",
      body: JSON.stringify({ election: newName })
    })
    .then(res => res.json())
    .then(resp => {
      if (resp.success && resp.electiontabs_html) {
        document.getElementById("election-tabs").innerHTML = resp.electiontabs_html;
        syncStreamsSelectWithTabs();
        updateConstantsUI(resp.constants, resp.options);
        fetchTableData('nodelist_xref');
        // ‚úÖ Onclick handlers already embedded

      } else {
        alert("Error adding election: " + resp.error);
      }
    });
  }


const toggle = document.getElementById("resources-toggle");
const container = document.getElementById("resources-container");

toggle.addEventListener("click", () => {
const isVisible = container.style.display === "block";
container.style.display = isVisible ? "none" : "block";
toggle.textContent = isVisible ? "Resources ‚¨á" : "Resources ‚¨Ü";
});

fetch("/get-constants", { credentials: 'same-origin' })
  .then(res => res.json())
  .then(data => {
    updateConstantsUI(data.constants, data.options);
    const mapfile = data.constants?.mapfiles?.slice(-1)[0];
    if (mapfile) {
      changeIframeSrc(`/thru/${mapfile}`);
    }
//    fetchTableData('nodelist_xref');
  });

  document.addEventListener("DOMContentLoaded", () => {

    // your code here


  const tabContainer = document.getElementById("election-tabs");

  // üîπ Load constants for the active election tab at startup
  const activeTab = tabContainer.querySelector(".election-tab.active");
  if (activeTab) {
    const selectedElection = activeTab.dataset.election;
    console.log("___activetab:",selectedElection);
    fetch("/set-election", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      credentials: "same-origin",
      body: JSON.stringify({ election: selectedElection })
    })
      .then(res => res.json())
      .then(resp => {
        if (resp.success) {
          fetch("/get-constants", { credentials: 'same-origin' })
            .then(res => res.json())
            .then(data => {
              updateConstantsUI(data.constants, data.options);
                const mapfile = data.constants?.mapfiles?.slice(-1)[0];
              if (mapfile) {
                changeIframeSrc(`/thru/${mapfile}`);
              }
            });
        }
      });
  };



syncStreamsSelectWithTabs();

  document.getElementById("update-territory-btn").addEventListener("click", () => {
    const activeTab = document.querySelector(".election-tab.active");
    if (!activeTab) {
      alert("No election selected.");
      return;
    }

    const election = activeTab.dataset.election;

    fetch("/update-territory", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      credentials: "same-origin",
      body: JSON.stringify({ election: election })
    })
      .then(res => res.json())
      .then(resp => {
        if (resp.success) {
          fetch("/get-constants", { credentials: 'same-origin' })
            .then(res => res.json())
            .then(data => {
              updateConstantsUI(data.constants, data.options);
                const mapfile = data.constants?.territory
              if (mapfile) {
                changeIframeSrc(`/thru/${mapfile}`);
              }
              fetchTableData('nodelist_xref');
            });
        }
      });
    });

    function updateDependentSelects(constants, options) {
    if (
      typeof constants !== "object" || constants === null ||
      typeof options !== "object" || options === null ||
      typeof options.resources !== "object" || options.resources === null
    ) {
      console.warn("updateDependentSelects: Missing or invalid constants/options/resources");
      return;
    }

    const dependentKeys = ["candidate", "campaignMgr"];
    const selectedResources = Array.isArray(constants.resources) ? constants.resources : [];

    dependentKeys.forEach(key => {
      const el = document.getElementById(key);
      if (!el) {
        console.warn(`updateDependentSelects: Element with id "${key}" not found`);
        return;
      }

      el.innerHTML = ""; // Clear existing options

      selectedResources.forEach(code => {
        const person = options.resources[code];
        if (!person || typeof person !== "object") {
          console.warn(`updateDependentSelects: No valid person found for code "${code}"`);
          return;
        }

        const option = document.createElement("option");
        option.value = code;
        option.textContent = `${person.Firstname ?? "?"} ${person.Surname ?? "?"}`.trim();
        if (constants[key] === code) option.selected = true;

        el.appendChild(option);
      });

      // Optional: If no resources matched, insert a placeholder
      if (el.options.length === 0) {
        const option = document.createElement("option");
        option.value = "";
        option.textContent = "No available options";
        el.appendChild(option);
      }
    });
  };

  document.addEventListener('click', function (e) {
      if (e.target.classList.contains('election-tab')) {
          // Remove active class from all tabs
          document.querySelectorAll('.election-tab').forEach(tab => {
              tab.classList.remove('active');
          });

          // Set clicked tab as active
          e.target.classList.add('active');

          // Sync select dropdown to match new active tab
          syncStreamsSelectWithTabs();
      }
  });


    document.getElementById('resources').addEventListener('blur', () => {
      console.log('Resources dropdown closed or lost focus');
      const el = document.getElementById('resources');
        const selected = Array.from(el.selectedOptions).map(opt => opt.value);

        fetch("/set-constant", {
          method: "POST",
          credentials: 'same-origin',
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            election: document.querySelector(".election-tab.active")?.dataset.election || "",
            name: "resources",
            value: selected
          })
        })
        .then(res => res.json())
        .then(resp => {
          if (resp.success) {
            // After setting, fetch latest constants and options
            fetch("/get-constants")
              .then(res => res.json())
              .then(({ constants, options }) => {
                updateDependentSelects(constants, options);  // Now safely updated
              });
          } else {
            alert("Failed to update resources: " + resp.error);
          }
        });
      });
});

function attachListenersToConstantFields(constants) {
  Object.keys(constants).forEach(key => {
    const el = document.getElementById(key);
    if (!el) return;

    const listener = () => {
      // Fetch updated constants/options from server and refresh UI
      fetch("/get-constants", { credentials: 'same-origin' })
        .then(res => res.json())
        .then(data => {
          updateConstantsUI(data.constants, data.options);
        });
    };

    // Remove any previous listeners (avoid duplicates)
    el.removeEventListener("change", listener);
    el.removeEventListener("input", listener);

    // Add appropriate listener depending on element type
    if (el.tagName === "SELECT" && el.multiple) {
      el.addEventListener("blur", listener); // For multi-selects
    } else {
      el.addEventListener("change", listener);
      el.addEventListener("input", listener);
    }
  });
}

document.addEventListener('change', function(e) {
  if (e.target && e.target.classList.contains('parent-dropdown')) {
    const select = e.target;
    const newParent = select.value;
    const oldParent = select.getAttribute('data-old-value');
    const subject = select.getAttribute('data-subject');
    console.log(`python- data received : select ${select} newP:${newParent} oldP:${oldParent} subject: ${subject}`);
    if (!subject) {
      console.error("‚ö† Could not find subject (node name) in row");
      return;
    }

    fetch('/reassign_parent', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        subject: subject,
        old_parent: oldParent,
        new_parent: newParent
      })
    })
    .then(response => response.json())
    .then(data => {
      if (data.status === 'success') {
        console.log("‚úÖ Reassignment complete:", data.message);
        window.location.href = data.mapfile;
        // Optionally update the UI or reload the map
      } else {
        console.error("‚ùå Reassignment failed:", data.message);
      }
    })
    .catch(error => {
      console.error("‚ùå Network or server error:", error);
    });
  }
});



</script>


{% endblock captains %}
